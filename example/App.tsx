import React, { useState } from "react";
import {
  Alert,
  Button,
  SafeAreaView,
  ScrollView,
  Text,
  View,
  StyleSheet,
  Image,
  Dimensions,
  TouchableOpacity,
} from "react-native";
import * as DocumentPicker from "expo-document-picker";
import * as FileSystem from "expo-file-system";
import * as VideoThumbnails from "expo-video-thumbnails";
import { Asset } from "expo-asset";
import ExpoObjectTracker, {
  BoundingBox,
  TrackingData,
  EffectConfig,
  PreviewFrame,
} from "expo-object-tracker";

import ObjectSelector from "./ObjectSelector";

export default function App() {
  const [videoUri, setVideoUri] = useState<string>("");
  const [thumbnailUri, setThumbnailUri] = useState<string>("");
  const [objectId, setObjectId] = useState<string>("");
  const [selectedBoundingBox, setSelectedBoundingBox] =
    useState<BoundingBox | null>(null);
  const [trackingResults, setTrackingResults] = useState<TrackingData[]>([]);
  const [previewFrames, setPreviewFrames] = useState<PreviewFrame[]>([]);
  const [currentPreviewEffect, setCurrentPreviewEffect] =
    useState<EffectConfig | null>(null);
  const [previewImages, setPreviewImages] = useState<{ [key: string]: string }>(
    {}
  );
  const [processedVideoUri, setProcessedVideoUri] = useState<string>("");
  const [status, setStatus] = useState<string>("Ready");
  const [showObjectSelector, setShowObjectSelector] = useState<boolean>(false);
  const [showObjectPreview, setShowObjectPreview] = useState<boolean>(false);
  const [detectedObjectPreview, setDetectedObjectPreview] =
    useState<string>("");
  const [videoResolution, setVideoResolution] = useState<{
    width: number;
    height: number;
  } | null>(null);

  const { width: screenWidth } = Dimensions.get("window");
  const thumbnailWidth = screenWidth - 40;
  const thumbnailHeight = (thumbnailWidth * 9) / 16; // 16:9 ÎπÑÏú®

  // ÎπÑÎîîÏò§ ÏÑ†ÌÉù
  const selectVideo = async () => {
    try {
      const result = await DocumentPicker.getDocumentAsync({
        type: "video/*",
        copyToCacheDirectory: true,
      });

      if (result.assets && result.assets.length > 0) {
        const uri = result.assets[0].uri;
        await loadVideo(uri);
      }
    } catch (error) {
      setStatus("Video selection failed");
      Alert.alert("Error", "Failed to select video");
      console.error("Video selection error:", error);
    }
  };

  // ÌÖåÏä§Ìä∏ ÎπÑÎîîÏò§ Î°úÎìú
  const loadTestVideo = async () => {
    try {
      setStatus("Loading test video...");

      // assetsÏóêÏÑú test-video.mp4 Î°úÎìú
      const asset = Asset.fromModule(require("./assets/test-video.mp4"));
      await asset.downloadAsync();

      await loadVideo(asset.localUri || asset.uri);
    } catch (error) {
      setStatus("Test video loading failed");
      Alert.alert("Error", "Failed to load test video");
      console.error("Test video loading error:", error);
    }
  };

  // Í≥µÌÜµ ÎπÑÎîîÏò§ Î°úÎî© Î°úÏßÅ
  const loadVideo = async (uri: string) => {
    try {
      setVideoUri(uri);
      setStatus("Generating thumbnail...");

      // Ïç∏ÎÑ§Ïùº ÏÉùÏÑ±
      const { uri: thumbnail } = await VideoThumbnails.getThumbnailAsync(uri, {
        time: 0,
        quality: 0.8,
      });

      setThumbnailUri(thumbnail);

      // ÎπÑÎîîÏò§ Ìï¥ÏÉÅÎèÑ Í∞ÄÏ†∏Ïò§Í∏∞
      const resolution = await ExpoObjectTracker.getVideoResolution(uri);
      setVideoResolution(resolution);
      console.log("Video resolution:", resolution);

      setStatus("Video loaded - Ready to select object");
      console.log("Video loaded:", uri);
      console.log("Thumbnail:", thumbnail);

      // Ïù¥Ï†Ñ Í≤∞Í≥ºÎì§ Ï¥àÍ∏∞Ìôî
      setObjectId("");
      setSelectedBoundingBox(null);
      setTrackingResults([]);
      setProcessedVideoUri("");
    } catch (error) {
      setStatus("Video processing failed");
      Alert.alert("Error", "Failed to process video");
      console.error("Video processing error:", error);
    }
  };

  // Í∞ùÏ≤¥ ÏÑ†ÌÉù ÌôîÎ©¥ ÌëúÏãú
  const showObjectSelection = () => {
    if (!thumbnailUri) {
      Alert.alert("Error", "Please select a video first");
      return;
    }
    setShowObjectSelector(true);
  };

  // Î∞îÏö¥Îî© Î∞ïÏä§ ÏÑ†ÌÉù ÏôÑÎ£å
  const onBoundingBoxSelected = async (boundingBox: BoundingBox) => {
    try {
      setStatus("Selecting object...");
      setSelectedBoundingBox(boundingBox);

      const id = await ExpoObjectTracker.selectObject(
        videoUri,
        0, // Ï≤´ Î≤àÏß∏ ÌîÑÎ†àÏûÑ
        boundingBox
      );

      setObjectId(id);

      // Í∞ùÏ≤¥ Ïù∏Ïãù ÎØ∏Î¶¨Î≥¥Í∏∞ ÏÉùÏÑ±
      setStatus("Generating object preview...");
      const previewUri = await ExpoObjectTracker.generateObjectPreview(
        videoUri,
        id
      );
      setDetectedObjectPreview(previewUri);

      setShowObjectSelector(false);
      setShowObjectPreview(true);
      setStatus("Object detected - Please confirm");
      console.log("Object ID:", id);
      console.log("Bounding Box:", boundingBox);
    } catch (error) {
      setStatus("Object selection failed");
      Alert.alert("Error", "Failed to select object: " + error);
      console.error("Object selection error:", error);
    }
  };

  // Í∞ùÏ≤¥ Ïù∏Ïãù ÌôïÏù∏
  const confirmObjectDetection = () => {
    setShowObjectPreview(false);
    setStatus("Object confirmed - Ready to track");
    Alert.alert("Success", "Object detection confirmed");
  };

  // Í∞ùÏ≤¥ Îã§Ïãú ÏÑ†ÌÉù
  const retryObjectSelection = () => {
    setShowObjectPreview(false);
    setShowObjectSelector(true);
    setObjectId("");
    setSelectedBoundingBox(null);
    setDetectedObjectPreview("");
    setStatus("Ready to select object again");
  };

  // Í∞ùÏ≤¥ Ï∂îÏ†Å
  const trackObject = async () => {
    if (!objectId) {
      Alert.alert("Error", "Please select object first");
      return;
    }

    try {
      setStatus("Tracking object...");

      const results = await ExpoObjectTracker.trackObject(videoUri, objectId);
      setTrackingResults(results);
      setStatus(`Tracking completed - ${results.length} frames`);

      // ÎØ∏Î¶¨Î≥¥Í∏∞ ÌîÑÎ†àÏûÑ ÏÉùÏÑ± (5Í∞ú ÌîÑÎ†àÏûÑ)
      setStatus("Generating preview frames...");
      const frames = await ExpoObjectTracker.generatePreviewFrames(
        videoUri,
        results,
        5
      );
      setPreviewFrames(frames);

      setStatus(`Tracking completed - Ready for effects preview`);
      Alert.alert("Success", `Tracked object in ${results.length} frames`);
      console.log("Tracking results:", results.slice(0, 5)); // Ï≤´ 5ÌîÑÎ†àÏûÑÎßå Î°úÍ∑∏
    } catch (error) {
      setStatus("Tracking failed");
      Alert.alert("Error", "Failed to track object: " + error);
      console.error("Object tracking error:", error);
    }
  };

  // Ìö®Í≥º ÎØ∏Î¶¨Î≥¥Í∏∞
  const previewEffect = async (
    effectConfig: EffectConfig,
    effectName: string
  ) => {
    if (previewFrames.length === 0) {
      Alert.alert("Error", "Please track object first");
      return;
    }

    try {
      setStatus(`Generating ${effectName} preview...`);
      setCurrentPreviewEffect(effectConfig);

      const newPreviewImages: { [key: string]: string } = {};

      // Í∞Å ÎØ∏Î¶¨Î≥¥Í∏∞ ÌîÑÎ†àÏûÑÏóê Ìö®Í≥º Ï†ÅÏö©
      for (const frame of previewFrames) {
        const processedUri = await ExpoObjectTracker.applyEffectToFrame(
          frame.imageUri,
          frame.boundingBox,
          effectConfig
        );
        newPreviewImages[`${effectName}-${frame.frameIndex}`] = processedUri;
      }

      setPreviewImages(newPreviewImages);
      setStatus(`${effectName} preview ready`);
    } catch (error) {
      setStatus("Preview generation failed");
      Alert.alert(
        "Error",
        `Failed to generate ${effectName} preview: ` + error
      );
      console.error("Preview generation error:", error);
    }
  };

  // ÏµúÏ¢Ö ÎπÑÎîîÏò§ Ï†ÄÏû•
  const saveVideo = async () => {
    if (!currentPreviewEffect || trackingResults.length === 0) {
      Alert.alert("Error", "Please preview an effect first");
      return;
    }

    try {
      setStatus("Saving video with effects...");

      const processedUri = await ExpoObjectTracker.applyEffectToTrackedObject(
        videoUri,
        trackingResults,
        currentPreviewEffect
      );

      setProcessedVideoUri(processedUri);
      setStatus("Video saved successfully");

      Alert.alert("Success", `Video saved at: ${processedUri}`);
      console.log("Processed video URI:", processedUri);
    } catch (error) {
      setStatus("Video save failed");
      Alert.alert("Error", "Failed to save video: " + error);
      console.error("Video save error:", error);
    }
  };

  // Í∞Å Ìö®Í≥ºÎ≥Ñ ÎØ∏Î¶¨Î≥¥Í∏∞ Ìï∏Îì§Îü¨Îì§
  const previewBlurEffect = () =>
    previewEffect({ type: "blur", intensity: 8 }, "blur");
  const previewMosaicEffect = () =>
    previewEffect({ type: "mosaic", blockSize: 15 }, "mosaic");
  const previewEmojiEffect = () =>
    previewEffect({ type: "emoji", emoji: "üòé", scale: 1.5 }, "emoji");
  const previewColorEffect = () =>
    previewEffect({ type: "color", color: "#FF0000", opacity: 0.7 }, "color");

  if (showObjectSelector && thumbnailUri) {
    return (
      <SafeAreaView style={styles.container}>
        <View style={styles.selectorContainer}>
          <Text style={styles.header}>Í∞ùÏ≤¥ ÏÑ†ÌÉùÌïòÍ∏∞</Text>
          <Text style={styles.instructionText}>
            Î∏îÎü¨ Ï≤òÎ¶¨Ìï† Í∞ùÏ≤¥Î•º ÎìúÎûòÍ∑∏Ìï¥ÏÑú ÏÑ†ÌÉùÌïòÏÑ∏Ïöî
          </Text>

          <ObjectSelector
            thumbnailUri={thumbnailUri}
            videoUri={videoUri}
            imageWidth={thumbnailWidth}
            imageHeight={thumbnailHeight}
            videoResolution={videoResolution}
            onBoundingBoxChange={onBoundingBoxSelected}
            onObjectDetected={(detections, selectedBox) => {
              console.log('Objects detected:', detections);
              console.log('In selected region:', selectedBox);
            }}
            onProcessingComplete={(results, processedVideoUri) => {
              console.log('Processing complete:', results.length, 'tracked objects');
              if (processedVideoUri) {
                console.log('Processed video:', processedVideoUri);
              }
            }}
            onCancel={() => setShowObjectSelector(false)}
          />
        </View>
      </SafeAreaView>
    );
  }

  if (showObjectPreview && detectedObjectPreview) {
    return (
      <SafeAreaView style={styles.container}>
        <View style={styles.selectorContainer}>
          <Text style={styles.header}>Í∞ùÏ≤¥ Ïù∏Ïãù ÌôïÏù∏</Text>
          <Text style={styles.instructionText}>
            Vision FrameworkÍ∞Ä Ïù∏ÏãùÌïú Í∞ùÏ≤¥ÏûÖÎãàÎã§. ÎßûÎã§Î©¥ ÌôïÏù∏ÏùÑ ÎàåÎü¨Ï£ºÏÑ∏Ïöî.
          </Text>

          <View style={styles.previewImageContainer}>
            <Image
              source={{ uri: detectedObjectPreview }}
              style={{
                width: thumbnailWidth,
                height: thumbnailHeight,
              }}
              resizeMode="contain"
            />
          </View>

          {selectedBoundingBox && (
            <View style={styles.detectionInfo}>
              <Text style={styles.detectionText}>
                Ïù∏ÏãùÎêú ÏòÅÏó≠ ÌÅ¨Í∏∞: {Math.round(selectedBoundingBox.width)} √ó{" "}
                {Math.round(selectedBoundingBox.height)}
              </Text>
              <Text style={styles.detectionText}>
                ÏúÑÏπò: ({Math.round(selectedBoundingBox.x)},{" "}
                {Math.round(selectedBoundingBox.y)})
              </Text>
            </View>
          )}

          <View style={styles.confirmButtonContainer}>
            <TouchableOpacity
              style={[styles.button, styles.retryButton]}
              onPress={retryObjectSelection}
            >
              <Text style={styles.buttonText}>Îã§Ïãú ÏÑ†ÌÉù</Text>
            </TouchableOpacity>

            <TouchableOpacity
              style={[styles.button, styles.confirmButton]}
              onPress={confirmObjectDetection}
            >
              <Text style={styles.buttonText}>ÌôïÏù∏</Text>
            </TouchableOpacity>
          </View>
        </View>
      </SafeAreaView>
    );
  }

  return (
    <SafeAreaView style={styles.container}>
      <ScrollView style={styles.container}>
        <Text style={styles.header}>Í∞ùÏ≤¥ Ï∂îÏ†Å & Î∏îÎü¨ Ï≤òÎ¶¨</Text>

        <Group name="Status">
          <Text style={styles.statusText}>{status}</Text>
        </Group>

        <Group name="1. ÎπÑÎîîÏò§ ÏÑ†ÌÉù">
          <View style={styles.effectButtonsContainer}>
            <Button title="Í∞§Îü¨Î¶¨ÏóêÏÑú ÏÑ†ÌÉù" onPress={selectVideo} />
            <Button title="ÌÖåÏä§Ìä∏ ÎπÑÎîîÏò§ ÏÇ¨Ïö©" onPress={loadTestVideo} />
          </View>
          {videoUri ? (
            <Text style={styles.infoText}>‚úì ÎπÑÎîîÏò§ Î°úÎìúÎê®</Text>
          ) : null}
        </Group>

        <Group name="2. Ï∂îÏ†ÅÌï† Í∞ùÏ≤¥ ÏÑ†ÌÉù">
          <Button
            title="Í∞ùÏ≤¥ ÏòÅÏó≠ ÏÑ†ÌÉùÌïòÍ∏∞"
            onPress={showObjectSelection}
            disabled={!thumbnailUri}
          />
          {objectId ? (
            <View>
              <Text style={styles.infoText}>‚úì Í∞ùÏ≤¥ ÏòÅÏó≠ ÏÑ†ÌÉùÎê®</Text>
              {selectedBoundingBox && (
                <Text style={styles.resultText}>
                  ÏúÑÏπò: ({Math.round(selectedBoundingBox.x)},{" "}
                  {Math.round(selectedBoundingBox.y)}) ÌÅ¨Í∏∞:{" "}
                  {Math.round(selectedBoundingBox.width)}√ó
                  {Math.round(selectedBoundingBox.height)}
                </Text>
              )}
            </View>
          ) : null}
        </Group>

        <Group name="3. Í∞ùÏ≤¥ Ï∂îÏ†Å">
          <Button
            title="Í∞ùÏ≤¥ Ï∂îÏ†ÅÌïòÍ∏∞"
            onPress={trackObject}
            disabled={!objectId}
          />
          {trackingResults.length > 0 ? (
            <Text style={styles.infoText}>
              ‚úì {trackingResults.length}ÌîÑÎ†àÏûÑÏóêÏÑú Ï∂îÏ†ÅÎê®
            </Text>
          ) : null}
        </Group>

        <Group name="4. Ìö®Í≥º ÎØ∏Î¶¨Î≥¥Í∏∞">
          <View style={styles.effectButtonsContainer}>
            <Button
              title="Î∏îÎü¨"
              onPress={previewBlurEffect}
              disabled={previewFrames.length === 0}
            />
            <Button
              title="Î™®ÏûêÏù¥ÌÅ¨"
              onPress={previewMosaicEffect}
              disabled={previewFrames.length === 0}
            />
          </View>
          <View style={styles.effectButtonsContainer}>
            <Button
              title="Ïù¥Î™®ÏßÄ üòé"
              onPress={previewEmojiEffect}
              disabled={previewFrames.length === 0}
            />
            <Button
              title="Îπ®Í∞ÑÏÉâ"
              onPress={previewColorEffect}
              disabled={previewFrames.length === 0}
            />
          </View>

          {/* ÎØ∏Î¶¨Î≥¥Í∏∞ Ïù¥ÎØ∏ÏßÄÎì§ */}
          {Object.keys(previewImages).length > 0 && (
            <View style={styles.previewContainer}>
              <Text style={styles.previewTitle}>Ìö®Í≥º ÎØ∏Î¶¨Î≥¥Í∏∞:</Text>
              <ScrollView horizontal showsHorizontalScrollIndicator={false}>
                {Object.entries(previewImages).map(([key, uri]) => (
                  <Image
                    key={key}
                    source={{ uri }}
                    style={styles.previewImage}
                    resizeMode="contain"
                  />
                ))}
              </ScrollView>
            </View>
          )}
        </Group>

        {currentPreviewEffect && (
          <Group name="5. ÎπÑÎîîÏò§ Ï†ÄÏû•">
            <Button
              title="Ìö®Í≥º Ï†ÅÏö©Îêú ÎπÑÎîîÏò§ Ï†ÄÏû•ÌïòÍ∏∞"
              onPress={saveVideo}
              disabled={!currentPreviewEffect}
            />
            {processedVideoUri ? (
              <Text style={styles.infoText}>‚úì ÎπÑÎîîÏò§ Ï†ÄÏû• ÏôÑÎ£å</Text>
            ) : null}
          </Group>
        )}

        {processedVideoUri && (
          <Group name="Í≤∞Í≥º">
            <Text style={styles.resultText}>
              Ï≤òÎ¶¨Îêú ÎπÑÎîîÏò§: {processedVideoUri}
            </Text>
          </Group>
        )}
      </ScrollView>
    </SafeAreaView>
  );
}

function Group(props: { name: string; children: React.ReactNode }) {
  return (
    <View style={styles.group}>
      <Text style={styles.groupHeader}>{props.name}</Text>
      {props.children}
    </View>
  );
}

const styles = StyleSheet.create({
  header: {
    fontSize: 24,
    fontWeight: "bold" as const,
    margin: 20,
    textAlign: "center" as const,
    color: "#333",
  },
  groupHeader: {
    fontSize: 18,
    fontWeight: "bold" as const,
    marginBottom: 15,
    color: "#444",
  },
  group: {
    margin: 15,
    backgroundColor: "#fff",
    borderRadius: 12,
    padding: 20,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  container: {
    flex: 1,
    backgroundColor: "#f5f5f5",
  },
  statusText: {
    fontSize: 16,
    fontWeight: "500" as const,
    color: "#007AFF",
    textAlign: "center" as const,
  },
  infoText: {
    fontSize: 14,
    color: "#28a745",
    marginTop: 10,
    textAlign: "center" as const,
  },
  resultText: {
    fontSize: 12,
    color: "#666",
    marginTop: 5,
  },
  selectorContainer: {
    flex: 1,
    padding: 20,
    alignItems: "center" as const,
  },
  instructionText: {
    fontSize: 16,
    color: "#666",
    textAlign: "center" as const,
    marginBottom: 20,
  },
  buttonContainer: {
    marginTop: 20,
    width: "100%",
  },
  effectButtonsContainer: {
    flexDirection: "row" as const,
    justifyContent: "space-around",
    marginBottom: 10,
  },
  previewContainer: {
    marginTop: 15,
    padding: 10,
    backgroundColor: "#f8f8f8",
    borderRadius: 8,
  },
  previewTitle: {
    fontSize: 14,
    fontWeight: "600" as const,
    marginBottom: 10,
    color: "#333",
  },
  previewImage: {
    width: 120,
    height: 90,
    marginRight: 10,
    borderRadius: 6,
    borderWidth: 1,
    borderColor: "#ddd",
  },
  previewImageContainer: {
    marginBottom: 20,
    borderRadius: 8,
    overflow: "hidden",
    borderWidth: 2,
    borderColor: "#4CAF50",
  },
  detectionInfo: {
    backgroundColor: "white",
    padding: 15,
    borderRadius: 8,
    marginBottom: 20,
    alignItems: "center" as const,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.2,
    shadowRadius: 2,
    elevation: 2,
  },
  detectionText: {
    fontSize: 14,
    color: "#333",
    marginBottom: 5,
    fontWeight: "500" as const,
  },
  confirmButtonContainer: {
    flexDirection: "row" as const,
    justifyContent: "space-around",
    width: "100%",
    maxWidth: 300,
  },
  retryButton: {
    backgroundColor: "#FF9800",
  },
  button: {
    paddingVertical: 12,
    paddingHorizontal: 20,
    borderRadius: 8,
    minWidth: 80,
    alignItems: "center" as const,
    margin: 5,
  },
  buttonText: {
    color: "white",
    fontSize: 16,
    fontWeight: "600" as const,
  },
  confirmButton: {
    backgroundColor: "#4CAF50",
  },
});
